# OnFabric MCP OAuth Authentication - MVP Implementation Plan

> **For Claude:** Use `${SUPERPOWERS_SKILLS_ROOT}/skills/collaboration/executing-plans/SKILL.md` to implement this plan task-by-task.

**Goal:** Implement OAuth 2.0 authentication flow for OnFabric MCP connection, allowing users to securely authenticate via browser and store access tokens.

**Architecture:** Authorization Code Flow with local redirect server. User clicks auth link ‚Üí logs in on OnFabric website ‚Üí redirects to localhost ‚Üí token saved to `.env` file ‚Üí MCP client loads token for future connections.

**Tech Stack:**
- `requests-oauthlib` for OAuth 2.0 flow
- `http.server` (stdlib) for local redirect server
- `python-dotenv` for token storage (already installed)
- `click` for CLI command (already installed)

---

## Prerequisites Understanding (For Junior Developers)

### What is OAuth 2.0?
OAuth 2.0 is like giving someone a temporary key to your house instead of your master key. When you log in to OnFabric through the browser, they give you an "access token" (temporary key) that proves you're authorized. Your app uses this token to access your data without ever seeing your password.

### Authorization Code Flow Steps:
1. **User clicks auth link** ‚Üí Opens browser to OnFabric login page
2. **User logs in** ‚Üí OnFabric knows who you are
3. **OnFabric redirects back** ‚Üí Sends you to `http://localhost:8080/callback?code=ABC123`
4. **Your app exchanges code for token** ‚Üí Trades temporary code for access token
5. **Token saved to .env** ‚Üí Store for future use
6. **Done!** ‚Üí Next time you run the app, it loads the token from `.env`

### Key Concepts:
- **Authorization Code**: Temporary code (1-time use) OnFabric sends back
- **Access Token**: Long-lived token your app uses to make API calls
- **Refresh Token**: (Optional) Used to get new access tokens when they expire
- **Redirect URI**: Where OnFabric sends the user after login (our localhost server)
- **Client ID**: Identifies your app to OnFabric (public, not secret)
- **Client Secret**: Password for your app (keep secret, never commit to git)

---

## Task 1: Install OAuth Dependencies

**Files:**
- Modify: `pyproject.toml:25-40` (dependencies section)

**Step 1: Add requests-oauthlib to dependencies**

Edit the `dependencies` list in `pyproject.toml`:

```toml
dependencies = [
    "langchain>=0.3.0",
    "langchain-anthropic>=0.3.0",
    "langchain-mcp>=0.1.0",
    "anthropic>=0.40.0",
    "click>=8.1.0",
    "rich>=13.0.0",
    "pydantic>=2.0.0",
    "pydantic-settings>=2.0.0",
    "httpx>=0.27.0",
    "python-dotenv>=1.0.0",
    "pyyaml>=6.0.0",
    "diskcache>=5.6.0",
    "tenacity>=8.0.0",
    "markdown>=3.7.0",
    "requests-oauthlib>=2.0.0",  # Add this line
]
```

**Step 2: Install the new dependency**

Run:
```bash
uv pip install -e .
```

Expected: `Successfully installed requests-oauthlib-2.0.0` (or similar)

**Step 3: Verify installation**

Run:
```bash
python -c "from requests_oauthlib import OAuth2Session; print('OAuth library installed!')"
```

Expected: `OAuth library installed!`

**Step 4: Commit**

```bash
git add pyproject.toml
git commit -m "feat: add requests-oauthlib dependency for OAuth flow"
```

---

## Task 2: Create OAuth Configuration Module

**Files:**
- Create: `fabric_dashboard/mcp/oauth_config.py`
- Test: `fabric_dashboard/tests/test_oauth_config.py`

**Step 1: Write the failing test**

Create `fabric_dashboard/tests/test_oauth_config.py`:

```python
"""Tests for OAuth configuration."""

import pytest
from fabric_dashboard.mcp.oauth_config import OAuthConfig


def test_oauth_config_has_required_fields():
    """Test that OAuthConfig has all required OAuth fields."""
    config = OAuthConfig()

    assert hasattr(config, "client_id")
    assert hasattr(config, "authorization_url")
    assert hasattr(config, "token_url")
    assert hasattr(config, "redirect_uri")
    assert hasattr(config, "scopes")


def test_oauth_config_redirect_uri_is_localhost():
    """Test that redirect URI points to localhost for local auth server."""
    config = OAuthConfig()

    assert config.redirect_uri.startswith("http://localhost:")
    assert "/callback" in config.redirect_uri


def test_oauth_config_scopes_not_empty():
    """Test that OAuth scopes are configured."""
    config = OAuthConfig()

    assert isinstance(config.scopes, list)
    assert len(config.scopes) > 0
```

**Step 2: Run test to verify it fails**

Run:
```bash
pytest fabric_dashboard/tests/test_oauth_config.py -v
```

Expected: FAIL with `ModuleNotFoundError: No module named 'fabric_dashboard.mcp.oauth_config'`

**Step 3: Write minimal implementation**

Create `fabric_dashboard/mcp/oauth_config.py`:

```python
"""OAuth configuration for OnFabric MCP authentication."""

from typing import List


class OAuthConfig:
    """OAuth 2.0 configuration for OnFabric MCP."""

    def __init__(self):
        """Initialize OAuth configuration."""
        # TODO: These values should come from OnFabric documentation
        # For now, using placeholder values that need to be updated
        self.client_id = "fabric-dashboard"  # Replace with actual client ID

        # OnFabric OAuth endpoints (update these URLs)
        self.authorization_url = "https://onfabric.com/oauth/authorize"
        self.token_url = "https://onfabric.com/oauth/token"

        # Local redirect server configuration
        self.redirect_uri = "http://localhost:8080/callback"
        self.redirect_port = 8080

        # OAuth scopes - what permissions we're requesting
        # Update based on what OnFabric MCP access requires
        self.scopes: List[str] = ["mcp:read", "mcp:write"]
```

**Step 4: Run test to verify it passes**

Run:
```bash
pytest fabric_dashboard/tests/test_oauth_config.py -v
```

Expected: 3 passed

**Step 5: Commit**

```bash
git add fabric_dashboard/mcp/oauth_config.py fabric_dashboard/tests/test_oauth_config.py
git commit -m "feat: add OAuth configuration module"
```

---

## Task 3: Create Local Redirect Server

**Files:**
- Create: `fabric_dashboard/mcp/oauth_server.py`
- Test: `fabric_dashboard/tests/test_oauth_server.py`

**Step 1: Write the failing test**

Create `fabric_dashboard/tests/test_oauth_server.py`:

```python
"""Tests for OAuth local redirect server."""

import pytest
from fabric_dashboard.mcp.oauth_server import LocalRedirectServer


def test_redirect_server_initialization():
    """Test that redirect server can be initialized."""
    server = LocalRedirectServer(port=8080)

    assert server.port == 8080
    assert server.authorization_code is None


def test_redirect_server_has_wait_for_callback_method():
    """Test that server has method to wait for OAuth callback."""
    server = LocalRedirectServer(port=8080)

    assert hasattr(server, "wait_for_callback")
    assert callable(server.wait_for_callback)
```

**Step 2: Run test to verify it fails**

Run:
```bash
pytest fabric_dashboard/tests/test_oauth_server.py -v
```

Expected: FAIL with `ModuleNotFoundError: No module named 'fabric_dashboard.mcp.oauth_server'`

**Step 3: Write minimal implementation**

Create `fabric_dashboard/mcp/oauth_server.py`:

```python
"""Local HTTP server for OAuth redirect callback."""

import http.server
import socketserver
import threading
import urllib.parse
from typing import Optional

from fabric_dashboard.utils import logger


class CallbackHandler(http.server.BaseHTTPRequestHandler):
    """HTTP request handler for OAuth callback."""

    def do_GET(self):
        """Handle GET request from OAuth redirect."""
        # Parse the URL query parameters
        query = urllib.parse.urlparse(self.path).query
        params = urllib.parse.parse_qs(query)

        # Extract authorization code from callback URL
        if "code" in params:
            # Store code in server instance
            self.server.authorization_code = params["code"][0]

            # Send success response to browser
            self.send_response(200)
            self.send_header("Content-type", "text/html")
            self.end_headers()

            html = """
            <html>
            <head><title>Authentication Successful</title></head>
            <body style="font-family: sans-serif; text-align: center; padding: 50px;">
                <h1>‚úÖ Authentication Successful!</h1>
                <p>You can close this window and return to your terminal.</p>
            </body>
            </html>
            """
            self.wfile.write(html.encode())
        else:
            # Handle error (no code in callback)
            self.send_response(400)
            self.send_header("Content-type", "text/html")
            self.end_headers()

            error = params.get("error", ["Unknown error"])[0]
            html = f"""
            <html>
            <head><title>Authentication Failed</title></head>
            <body style="font-family: sans-serif; text-align: center; padding: 50px;">
                <h1>‚ùå Authentication Failed</h1>
                <p>Error: {error}</p>
                <p>Please close this window and try again.</p>
            </body>
            </html>
            """
            self.wfile.write(html.encode())

    def log_message(self, format, *args):
        """Suppress default HTTP server logging."""
        # Only log errors, not every request
        if "404" in str(args) or "500" in str(args):
            logger.warning(f"OAuth callback error: {args}")


class LocalRedirectServer:
    """Local HTTP server to receive OAuth callback."""

    def __init__(self, port: int = 8080):
        """
        Initialize local redirect server.

        Args:
            port: Port to run the server on (default: 8080).
        """
        self.port = port
        self.authorization_code: Optional[str] = None
        self._server: Optional[socketserver.TCPServer] = None

    def wait_for_callback(self, timeout: int = 300) -> Optional[str]:
        """
        Start server and wait for OAuth callback.

        Args:
            timeout: Maximum seconds to wait for callback (default: 300 = 5 minutes).

        Returns:
            Authorization code from callback, or None if timeout/error.
        """
        logger.info(f"Starting local redirect server on port {self.port}...")

        try:
            # Create server
            self._server = socketserver.TCPServer(("", self.port), CallbackHandler)

            # Store reference to authorization code in server instance
            self._server.authorization_code = None

            # Run server in background thread with timeout
            def serve():
                logger.muted("Waiting for OAuth callback...")
                # Handle one request (the callback), then stop
                self._server.handle_request()

            server_thread = threading.Thread(target=serve, daemon=True)
            server_thread.start()

            # Wait for callback (or timeout)
            server_thread.join(timeout=timeout)

            # Get the authorization code from server instance
            if hasattr(self._server, "authorization_code"):
                self.authorization_code = self._server.authorization_code

            if self.authorization_code:
                logger.success("Received authorization code from callback")
                return self.authorization_code
            else:
                logger.error("Timeout waiting for OAuth callback")
                return None

        except OSError as e:
            logger.error(f"Failed to start redirect server: {e}")
            logger.info("Make sure port {self.port} is not already in use")
            return None
        finally:
            if self._server:
                self._server.server_close()
```

**Step 4: Run test to verify it passes**

Run:
```bash
pytest fabric_dashboard/tests/test_oauth_server.py -v
```

Expected: 2 passed

**Step 5: Commit**

```bash
git add fabric_dashboard/mcp/oauth_server.py fabric_dashboard/tests/test_oauth_server.py
git commit -m "feat: add local redirect server for OAuth callback"
```

---

## Task 4: Create OAuth Flow Manager

**Files:**
- Create: `fabric_dashboard/mcp/oauth_flow.py`
- Test: `fabric_dashboard/tests/test_oauth_flow.py`

**Step 1: Write the failing test**

Create `fabric_dashboard/tests/test_oauth_flow.py`:

```python
"""Tests for OAuth flow manager."""

import pytest
from unittest.mock import Mock, patch
from fabric_dashboard.mcp.oauth_flow import OAuthFlowManager


def test_oauth_flow_manager_initialization():
    """Test that OAuth flow manager initializes with config."""
    manager = OAuthFlowManager()

    assert hasattr(manager, "config")
    assert hasattr(manager, "get_authorization_url")
    assert hasattr(manager, "exchange_code_for_token")


def test_get_authorization_url_returns_valid_url():
    """Test that authorization URL is generated correctly."""
    manager = OAuthFlowManager()

    auth_url = manager.get_authorization_url()

    assert isinstance(auth_url, str)
    assert auth_url.startswith("https://")
    assert "oauth" in auth_url.lower() or "authorize" in auth_url.lower()


@patch("fabric_dashboard.mcp.oauth_flow.OAuth2Session")
def test_exchange_code_for_token_calls_fetch_token(mock_session):
    """Test that code exchange calls OAuth2Session.fetch_token()."""
    # Mock OAuth2Session behavior
    mock_instance = Mock()
    mock_instance.fetch_token.return_value = {
        "access_token": "test_token_123",
        "token_type": "Bearer",
        "expires_in": 3600,
    }
    mock_session.return_value = mock_instance

    manager = OAuthFlowManager()
    token = manager.exchange_code_for_token("test_auth_code")

    assert token is not None
    assert "access_token" in token
    assert token["access_token"] == "test_token_123"
```

**Step 2: Run test to verify it fails**

Run:
```bash
pytest fabric_dashboard/tests/test_oauth_flow.py -v
```

Expected: FAIL with `ModuleNotFoundError: No module named 'fabric_dashboard.mcp.oauth_flow'`

**Step 3: Write minimal implementation**

Create `fabric_dashboard/mcp/oauth_flow.py`:

```python
"""OAuth 2.0 authorization flow manager."""

from typing import Any, Dict, Optional
import webbrowser

from requests_oauthlib import OAuth2Session

from fabric_dashboard.mcp.oauth_config import OAuthConfig
from fabric_dashboard.mcp.oauth_server import LocalRedirectServer
from fabric_dashboard.utils import logger


class OAuthFlowManager:
    """Manages OAuth 2.0 authorization code flow."""

    def __init__(self):
        """Initialize OAuth flow manager with config."""
        self.config = OAuthConfig()

    def get_authorization_url(self) -> str:
        """
        Generate OAuth authorization URL.

        Returns:
            Authorization URL to open in browser.
        """
        # Create OAuth2 session
        oauth = OAuth2Session(
            client_id=self.config.client_id,
            redirect_uri=self.config.redirect_uri,
            scope=self.config.scopes,
        )

        # Generate authorization URL
        authorization_url, state = oauth.authorization_url(
            self.config.authorization_url
        )

        logger.muted(f"Generated authorization URL with state: {state[:8]}...")
        return authorization_url

    def exchange_code_for_token(
        self,
        authorization_code: str,
        client_secret: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Exchange authorization code for access token.

        Args:
            authorization_code: The code received from OAuth callback.
            client_secret: Optional client secret for confidential clients.

        Returns:
            Token dictionary with access_token, or None if exchange fails.
        """
        logger.info("Exchanging authorization code for access token...")

        try:
            # Create OAuth2 session
            oauth = OAuth2Session(
                client_id=self.config.client_id,
                redirect_uri=self.config.redirect_uri,
            )

            # Exchange code for token
            token = oauth.fetch_token(
                self.config.token_url,
                code=authorization_code,
                client_secret=client_secret,  # Only needed if OnFabric requires it
                include_client_id=True,
            )

            logger.success("Successfully obtained access token")
            return token

        except Exception as e:
            logger.error(f"Failed to exchange code for token: {e}")
            return None

    def run_interactive_flow(self) -> Optional[Dict[str, Any]]:
        """
        Run complete interactive OAuth flow.

        This method:
        1. Starts local redirect server
        2. Opens browser to authorization URL
        3. Waits for callback with code
        4. Exchanges code for token

        Returns:
            Token dictionary, or None if flow fails.
        """
        logger.info("Starting OAuth authorization flow...")

        # Step 1: Start local redirect server
        server = LocalRedirectServer(port=self.config.redirect_port)

        # Step 2: Generate and open authorization URL
        auth_url = self.get_authorization_url()

        logger.info("Opening browser for authorization...")
        logger.info(f"If browser doesn't open, visit: {auth_url}")

        try:
            webbrowser.open(auth_url)
        except Exception as e:
            logger.warning(f"Could not auto-open browser: {e}")
            logger.info("Please manually open the URL above")

        # Step 3: Wait for callback
        authorization_code = server.wait_for_callback(timeout=300)

        if not authorization_code:
            logger.error("Failed to receive authorization code")
            return None

        # Step 4: Exchange code for token
        token = self.exchange_code_for_token(authorization_code)

        return token
```

**Step 4: Run test to verify it passes**

Run:
```bash
pytest fabric_dashboard/tests/test_oauth_flow.py -v
```

Expected: 3 passed

**Step 5: Commit**

```bash
git add fabric_dashboard/mcp/oauth_flow.py fabric_dashboard/tests/test_oauth_flow.py
git commit -m "feat: add OAuth flow manager with interactive browser flow"
```

---

## Task 5: Create Token Storage Module

**Files:**
- Create: `fabric_dashboard/mcp/token_storage.py`
- Test: `fabric_dashboard/tests/test_token_storage.py`

**Step 1: Write the failing test**

Create `fabric_dashboard/tests/test_token_storage.py`:

```python
"""Tests for OAuth token storage."""

import os
import tempfile
from pathlib import Path
import pytest
from fabric_dashboard.mcp.token_storage import TokenStorage


@pytest.fixture
def temp_env_file():
    """Create temporary .env file for testing."""
    with tempfile.NamedTemporaryFile(mode="w", suffix=".env", delete=False) as f:
        f.write("# Test env file\n")
        f.write("EXISTING_VAR=value\n")
        temp_path = f.name

    yield temp_path

    # Cleanup
    if os.path.exists(temp_path):
        os.unlink(temp_path)


def test_token_storage_initialization():
    """Test that token storage can be initialized."""
    storage = TokenStorage()

    assert hasattr(storage, "save_token")
    assert hasattr(storage, "load_token")
    assert hasattr(storage, "has_token")


def test_save_token_creates_env_entries(temp_env_file):
    """Test that saving token adds entries to .env file."""
    storage = TokenStorage(env_file=temp_env_file)

    test_token = {
        "access_token": "test_access_token_123",
        "token_type": "Bearer",
        "expires_in": 3600,
    }

    storage.save_token(test_token)

    # Read .env file and check contents
    with open(temp_env_file, "r") as f:
        contents = f.read()

    assert "ONFABRIC_ACCESS_TOKEN=test_access_token_123" in contents
    assert "ONFABRIC_TOKEN_TYPE=Bearer" in contents


def test_load_token_reads_from_env(temp_env_file):
    """Test that loading token reads from .env file."""
    # Add token to env file
    with open(temp_env_file, "a") as f:
        f.write("ONFABRIC_ACCESS_TOKEN=saved_token_456\n")
        f.write("ONFABRIC_TOKEN_TYPE=Bearer\n")

    storage = TokenStorage(env_file=temp_env_file)
    token = storage.load_token()

    assert token is not None
    assert token["access_token"] == "saved_token_456"
    assert token["token_type"] == "Bearer"


def test_has_token_returns_false_when_no_token(temp_env_file):
    """Test that has_token returns False when no token exists."""
    storage = TokenStorage(env_file=temp_env_file)

    assert storage.has_token() is False


def test_has_token_returns_true_when_token_exists(temp_env_file):
    """Test that has_token returns True when token exists."""
    # Add token to env file
    with open(temp_env_file, "a") as f:
        f.write("ONFABRIC_ACCESS_TOKEN=token_exists\n")

    storage = TokenStorage(env_file=temp_env_file)

    assert storage.has_token() is True
```

**Step 2: Run test to verify it fails**

Run:
```bash
pytest fabric_dashboard/tests/test_token_storage.py -v
```

Expected: FAIL with `ModuleNotFoundError: No module named 'fabric_dashboard.mcp.token_storage'`

**Step 3: Write minimal implementation**

Create `fabric_dashboard/mcp/token_storage.py`:

```python
"""Token storage for OAuth credentials."""

import os
from pathlib import Path
from typing import Any, Dict, Optional

from dotenv import load_dotenv, set_key

from fabric_dashboard.utils import logger


class TokenStorage:
    """Handles storing and loading OAuth tokens from .env file."""

    def __init__(self, env_file: Optional[str] = None):
        """
        Initialize token storage.

        Args:
            env_file: Path to .env file. If None, uses .env in project root.
        """
        if env_file is None:
            # Default to .env in project root
            project_root = Path(__file__).parent.parent.parent
            env_file = project_root / ".env"

        self.env_file = Path(env_file)

        # Create .env file if it doesn't exist
        if not self.env_file.exists():
            logger.info(f"Creating .env file at {self.env_file}")
            self.env_file.touch()

    def save_token(self, token: Dict[str, Any]) -> None:
        """
        Save OAuth token to .env file.

        Args:
            token: Token dictionary from OAuth flow.
        """
        logger.info(f"Saving OAuth token to {self.env_file}")

        # Save access token (required)
        if "access_token" in token:
            set_key(str(self.env_file), "ONFABRIC_ACCESS_TOKEN", token["access_token"])

        # Save token type
        if "token_type" in token:
            set_key(str(self.env_file), "ONFABRIC_TOKEN_TYPE", token["token_type"])

        # Save refresh token (if provided)
        if "refresh_token" in token:
            set_key(str(self.env_file), "ONFABRIC_REFRESH_TOKEN", token["refresh_token"])

        # Save expiry (if provided)
        if "expires_in" in token:
            set_key(str(self.env_file), "ONFABRIC_TOKEN_EXPIRES_IN", str(token["expires_in"]))

        logger.success("OAuth token saved successfully")

    def load_token(self) -> Optional[Dict[str, Any]]:
        """
        Load OAuth token from .env file.

        Returns:
            Token dictionary, or None if no token found.
        """
        # Load environment variables from .env file
        load_dotenv(self.env_file)

        # Check if access token exists
        access_token = os.getenv("ONFABRIC_ACCESS_TOKEN")

        if not access_token:
            return None

        # Build token dictionary
        token = {
            "access_token": access_token,
            "token_type": os.getenv("ONFABRIC_TOKEN_TYPE", "Bearer"),
        }

        # Add optional fields if present
        if refresh_token := os.getenv("ONFABRIC_REFRESH_TOKEN"):
            token["refresh_token"] = refresh_token

        if expires_in := os.getenv("ONFABRIC_TOKEN_EXPIRES_IN"):
            try:
                token["expires_in"] = int(expires_in)
            except ValueError:
                logger.warning(f"Invalid expires_in value: {expires_in}")

        logger.muted("Loaded OAuth token from .env")
        return token

    def has_token(self) -> bool:
        """
        Check if OAuth token exists.

        Returns:
            True if token exists, False otherwise.
        """
        load_dotenv(self.env_file)
        return os.getenv("ONFABRIC_ACCESS_TOKEN") is not None
```

**Step 4: Run test to verify it passes**

Run:
```bash
pytest fabric_dashboard/tests/test_token_storage.py -v
```

Expected: 5 passed

**Step 5: Commit**

```bash
git add fabric_dashboard/mcp/token_storage.py fabric_dashboard/tests/test_token_storage.py
git commit -m "feat: add token storage with .env file persistence"
```

---

## Task 6: Create CLI Auth Command

**Files:**
- Create: `fabric_dashboard/commands/auth.py`
- Modify: `fabric_dashboard/cli.py:1-50` (add auth command)
- Test: `fabric_dashboard/tests/test_auth_command.py`

**Step 1: Write the failing test**

Create `fabric_dashboard/tests/test_auth_command.py`:

```python
"""Tests for auth CLI command."""

import pytest
from click.testing import CliRunner
from unittest.mock import Mock, patch
from fabric_dashboard.commands.auth import auth


def test_auth_command_exists():
    """Test that auth command is defined."""
    assert auth is not None
    assert callable(auth)


@patch("fabric_dashboard.commands.auth.OAuthFlowManager")
@patch("fabric_dashboard.commands.auth.TokenStorage")
def test_auth_command_runs_oauth_flow(mock_storage, mock_flow):
    """Test that auth command runs OAuth flow and saves token."""
    # Mock successful OAuth flow
    mock_flow_instance = Mock()
    mock_flow_instance.run_interactive_flow.return_value = {
        "access_token": "test_token",
        "token_type": "Bearer",
    }
    mock_flow.return_value = mock_flow_instance

    # Mock token storage
    mock_storage_instance = Mock()
    mock_storage.return_value = mock_storage_instance

    # Run command
    runner = CliRunner()
    result = runner.invoke(auth)

    # Check that OAuth flow was run
    mock_flow_instance.run_interactive_flow.assert_called_once()

    # Check that token was saved
    mock_storage_instance.save_token.assert_called_once()

    # Check command succeeded
    assert result.exit_code == 0


@patch("fabric_dashboard.commands.auth.OAuthFlowManager")
def test_auth_command_handles_oauth_failure(mock_flow):
    """Test that auth command handles OAuth flow failure gracefully."""
    # Mock failed OAuth flow
    mock_flow_instance = Mock()
    mock_flow_instance.run_interactive_flow.return_value = None
    mock_flow.return_value = mock_flow_instance

    # Run command
    runner = CliRunner()
    result = runner.invoke(auth)

    # Check command failed
    assert result.exit_code != 0
```

**Step 2: Run test to verify it fails**

Run:
```bash
pytest fabric_dashboard/tests/test_auth_command.py -v
```

Expected: FAIL with `ModuleNotFoundError: No module named 'fabric_dashboard.commands.auth'`

**Step 3: Write minimal implementation**

Create `fabric_dashboard/commands/auth.py`:

```python
"""CLI command for OnFabric OAuth authentication."""

import click
from rich.console import Console

from fabric_dashboard.mcp.oauth_flow import OAuthFlowManager
from fabric_dashboard.mcp.token_storage import TokenStorage

console = Console()


@click.command()
def auth():
    """
    Authenticate with OnFabric using OAuth 2.0.

    This command:
    1. Opens your browser to OnFabric login page
    2. Waits for you to log in and authorize the app
    3. Saves the access token to your .env file

    After authentication, you can use other commands to access your OnFabric data.
    """
    console.print("\n[bold cyan]üîê OnFabric OAuth Authentication[/bold cyan]\n")

    # Check if already authenticated
    storage = TokenStorage()
    if storage.has_token():
        console.print("‚ö†Ô∏è  You are already authenticated.")

        if not click.confirm("Do you want to re-authenticate?", default=False):
            console.print("\n‚úÖ Keeping existing authentication.\n")
            return 0

        console.print("\nüîÑ Re-authenticating...\n")

    # Run OAuth flow
    console.print("[dim]Step 1: Opening browser for authorization...[/dim]")
    console.print("[dim]Step 2: Log in to OnFabric in your browser[/dim]")
    console.print("[dim]Step 3: Authorize Fabric Dashboard to access your data[/dim]")
    console.print("[dim]Step 4: Wait for redirect (this may take a moment)[/dim]\n")

    flow_manager = OAuthFlowManager()
    token = flow_manager.run_interactive_flow()

    if not token:
        console.print("\n[bold red]‚ùå Authentication failed[/bold red]")
        console.print("Please try again or check your internet connection.\n")
        raise click.Abort()

    # Save token
    storage.save_token(token)

    console.print("\n[bold green]‚úÖ Authentication successful![/bold green]")
    console.print("Your access token has been saved to .env\n")
    console.print("You can now use other commands to access your OnFabric data.\n")

    return 0
```

**Step 4: Run test to verify it passes**

Run:
```bash
pytest fabric_dashboard/tests/test_auth_command.py -v
```

Expected: 3 passed

**Step 5: Add command to CLI**

Edit `fabric_dashboard/cli.py` and add the auth command:

```python
"""CLI entry point for fabric-dashboard."""

import click

from fabric_dashboard.commands.generate import generate
from fabric_dashboard.commands.init import init
from fabric_dashboard.commands.auth import auth  # Add this import


@click.group()
@click.version_option()
def main():
    """Fabric Intelligence Dashboard - Generate personalized AI-powered dashboards."""
    pass


# Register commands
main.add_command(generate)
main.add_command(init)
main.add_command(auth)  # Add this line


if __name__ == "__main__":
    main()
```

**Step 6: Test CLI integration**

Run:
```bash
fabric-dashboard auth --help
```

Expected: Help text for auth command is displayed

**Step 7: Commit**

```bash
git add fabric_dashboard/commands/auth.py fabric_dashboard/cli.py fabric_dashboard/tests/test_auth_command.py
git commit -m "feat: add auth CLI command for OAuth authentication"
```

---

## Task 7: Update MCPClient to Load Token

**Files:**
- Modify: `fabric_dashboard/mcp/client.py:1-81`
- Test: `fabric_dashboard/tests/test_mcp_client_oauth.py`

**Step 1: Write the failing test**

Create `fabric_dashboard/tests/test_mcp_client_oauth.py`:

```python
"""Tests for MCP client OAuth integration."""

import pytest
from unittest.mock import Mock, patch
from fabric_dashboard.mcp.client import MCPClient


@patch("fabric_dashboard.mcp.client.TokenStorage")
def test_mcp_client_loads_token_on_connect(mock_storage):
    """Test that MCPClient loads OAuth token when connecting."""
    # Mock token storage
    mock_storage_instance = Mock()
    mock_storage_instance.load_token.return_value = {
        "access_token": "test_token_123",
        "token_type": "Bearer",
    }
    mock_storage.return_value = mock_storage_instance

    # Create client and connect
    client = MCPClient(server_name="onfabric")
    result = client.connect()

    # Verify token was loaded
    mock_storage_instance.load_token.assert_called_once()

    # Verify token is stored in client
    assert hasattr(client, "access_token")
    assert client.access_token == "test_token_123"

    # Connection should succeed
    assert result is True


@patch("fabric_dashboard.mcp.client.TokenStorage")
def test_mcp_client_fails_when_no_token(mock_storage):
    """Test that MCPClient fails to connect when no token exists."""
    # Mock no token
    mock_storage_instance = Mock()
    mock_storage_instance.load_token.return_value = None
    mock_storage.return_value = mock_storage_instance

    # Create client and try to connect
    client = MCPClient(server_name="onfabric")
    result = client.connect()

    # Connection should fail
    assert result is False


def test_mcp_client_has_is_authenticated_method():
    """Test that MCPClient has method to check authentication status."""
    client = MCPClient(server_name="onfabric")

    assert hasattr(client, "is_authenticated")
    assert callable(client.is_authenticated)
```

**Step 2: Run test to verify it fails**

Run:
```bash
pytest fabric_dashboard/tests/test_mcp_client_oauth.py -v
```

Expected: FAIL - tests fail because MCPClient doesn't load tokens yet

**Step 3: Update MCPClient implementation**

Edit `fabric_dashboard/mcp/client.py`:

```python
"""Base MCP client for fabric_dashboard."""

from typing import Any, Optional

from fabric_dashboard.mcp.token_storage import TokenStorage
from fabric_dashboard.utils import logger


class MCPClient:
    """Base Model Context Protocol client."""

    def __init__(self, server_name: str, connection_params: Optional[dict[str, Any]] = None):
        """
        Initialize MCP client.

        Args:
            server_name: Name of the MCP server to connect to.
            connection_params: Optional connection parameters.
        """
        self.server_name = server_name
        self.connection_params = connection_params or {}
        self._connected = False
        self.access_token: Optional[str] = None
        self.token_type: str = "Bearer"

    def is_authenticated(self) -> bool:
        """
        Check if client has valid authentication token.

        Returns:
            True if access token is loaded, False otherwise.
        """
        return self.access_token is not None

    def connect(self) -> bool:
        """
        Connect to MCP server.

        Returns:
            True if connection successful, False otherwise.
        """
        try:
            logger.info(f"Connecting to MCP server: {self.server_name}")

            # Load OAuth token
            storage = TokenStorage()
            token = storage.load_token()

            if not token:
                logger.error("No OAuth token found. Please run 'fabric-dashboard auth' first.")
                return False

            # Store token for API calls
            self.access_token = token.get("access_token")
            self.token_type = token.get("token_type", "Bearer")

            if not self.access_token:
                logger.error("Invalid token: missing access_token")
                return False

            logger.muted(f"Loaded OAuth token: {self.access_token[:8]}...")

            # TODO: Use access_token to establish real MCP connection
            # For now, just mark as connected
            self._connected = True

            logger.success(f"Connected to {self.server_name} (OAuth authenticated)")
            return True

        except Exception as e:
            logger.error(f"Failed to connect to MCP server: {e}")
            self._connected = False
            return False

    def disconnect(self) -> None:
        """Disconnect from MCP server."""
        if self._connected:
            logger.info(f"Disconnecting from {self.server_name}")
            self._connected = False
            self.access_token = None

    def is_connected(self) -> bool:
        """Check if connected to MCP server."""
        return self._connected

    def call_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
        """
        Call an MCP tool.

        Args:
            tool_name: Name of the tool to call.
            arguments: Tool arguments.

        Returns:
            Tool result.

        Raises:
            RuntimeError: If not connected to MCP server.
        """
        if not self._connected:
            raise RuntimeError(f"Not connected to MCP server: {self.server_name}")

        if not self.is_authenticated():
            raise RuntimeError("Not authenticated. Please run 'fabric-dashboard auth' first.")

        logger.muted(f"Calling MCP tool: {tool_name}")

        # TODO: Implement actual tool calling with OAuth token in headers
        # Headers should include: Authorization: Bearer {self.access_token}
        raise NotImplementedError("MCP tool calling not yet implemented")

    def __enter__(self) -> "MCPClient":
        """Context manager entry."""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.disconnect()
```

**Step 4: Run test to verify it passes**

Run:
```bash
pytest fabric_dashboard/tests/test_mcp_client_oauth.py -v
```

Expected: 3 passed

**Step 5: Commit**

```bash
git add fabric_dashboard/mcp/client.py fabric_dashboard/tests/test_mcp_client_oauth.py
git commit -m "feat: integrate OAuth token loading into MCP client"
```

---

## Task 8: Update .env.example with OAuth Variables

**Files:**
- Modify: `.env.example:1-40`

**Step 1: Add OAuth documentation to .env.example**

Edit `.env.example` and add OAuth section:

```bash
# Claude API Configuration
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Perplexity API Configuration
PERPLEXITY_API_KEY=your_perplexity_api_key_here

# Optional: Number of days back to fetch user data (default: 30)
DAYS_BACK=30

# Optional: Debug mode
DEBUG=false

# ============================================================================
# OnFabric OAuth Authentication
# ============================================================================
# These are automatically set when you run: fabric-dashboard auth
# DO NOT manually edit these - use the auth command instead

ONFABRIC_ACCESS_TOKEN=
ONFABRIC_TOKEN_TYPE=Bearer
ONFABRIC_REFRESH_TOKEN=
ONFABRIC_TOKEN_EXPIRES_IN=

# ============================================================================
# Optional: External APIs for UI Component Enrichment
# ============================================================================

# OpenWeatherMap API (weather widgets)
# Free tier: 1,000 calls/day
# Sign up: https://openweathermap.org/api
# Get key: https://home.openweathermap.org/api_keys
OPENWEATHERMAP_API_KEY=

# YouTube Data API v3 (video feeds)
# Free tier: 10,000 units/day (100 searches)
# Enable: https://console.cloud.google.com/apis/library/youtube.googleapis.com
# Get key: https://console.cloud.google.com/apis/credentials
YOUTUBE_API_KEY=

# Ticketmaster Discovery API (event calendars)
# Free tier: 5,000 requests/day
# Sign up: https://developer.ticketmaster.com/products-and-docs/apis/getting-started/
# Get key: https://developer-acct.ticketmaster.com/user/register
TICKETMASTER_API_KEY=

# Mapbox API (geocoding & maps)
# Free tier: 100,000 requests/month for geocoding
# Sign up: https://account.mapbox.com/
# Get token: https://account.mapbox.com/access-tokens/
MAPBOX_API_KEY=
```

**Step 2: Commit**

```bash
git add .env.example
git commit -m "docs: add OAuth variables to .env.example"
```

---

## Task 9: Update README with Auth Instructions

**Files:**
- Modify: `README.md:40-77`

**Step 1: Add OAuth authentication section to README**

Edit `README.md` and add authentication section after installation:

```markdown
## Installation

[... existing installation steps ...]

4. **Configure environment**
   ```bash
   cp .env.example .env
   # Edit .env and add your API keys:
   # ANTHROPIC_API_KEY=your_key_here
   # PERPLEXITY_API_KEY=your_key_here
   ```

5. **Authenticate with OnFabric**
   ```bash
   fabric-dashboard auth
   ```

   This will:
   - Open your browser to OnFabric's login page
   - Ask you to authorize Fabric Dashboard
   - Save your access token to `.env` automatically

   **Note**: You only need to do this once. The token is saved and reused for future commands.

## Usage

### First Time Setup

Before generating dashboards, authenticate with OnFabric:

```bash
fabric-dashboard auth
```

This opens your browser for a secure OAuth login. After authorizing the app, your access token is saved automatically.

### Generate Dashboard

[... existing usage instructions ...]
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add OAuth authentication instructions to README"
```

---

## Task 10: Manual Testing & Validation

**Files:**
- None (manual testing)

**Step 1: Test auth command with mock OAuth server**

Since we don't have real OnFabric OAuth credentials yet, we'll test the flow manually:

Run:
```bash
fabric-dashboard auth
```

**What to check:**
1. ‚úÖ Command starts without errors
2. ‚úÖ Browser opens (or URL is displayed)
3. ‚ö†Ô∏è  OAuth redirect will fail (expected - we don't have real credentials)
4. ‚úÖ Error message is clear and helpful

**Expected behavior:**
- Local server starts on port 8080
- Browser opens to authorization URL
- Server waits for callback
- Timeout after 5 minutes if no callback

**Step 2: Test with saved token**

Manually add a test token to `.env`:

```bash
echo "ONFABRIC_ACCESS_TOKEN=test_token_12345" >> .env
echo "ONFABRIC_TOKEN_TYPE=Bearer" >> .env
```

Then test that MCPClient can load it:

Run:
```bash
python -c "
from fabric_dashboard.mcp.client import MCPClient

client = MCPClient('onfabric')
success = client.connect()
print(f'Connected: {success}')
print(f'Authenticated: {client.is_authenticated()}')
print(f'Token: {client.access_token[:10]}...' if client.access_token else 'No token')
"
```

Expected output:
```
Connected: True
Authenticated: True
Token: test_token...
```

**Step 3: Test re-authentication flow**

Run:
```bash
fabric-dashboard auth
```

**What to check:**
1. ‚úÖ Shows "already authenticated" message
2. ‚úÖ Asks if you want to re-authenticate
3. ‚úÖ Responds correctly to yes/no

**Step 4: Run full test suite**

Run:
```bash
pytest fabric_dashboard/tests/ -v --tb=short
```

Expected: All tests pass

**Step 5: Document findings**

Create a note about what needs to be configured once real OnFabric OAuth is available:

```bash
echo "# OAuth Configuration TODO

Before this can work with real OnFabric:

1. Update fabric_dashboard/mcp/oauth_config.py with:
   - Real client_id from OnFabric
   - Real authorization_url (e.g., https://onfabric.com/oauth/authorize)
   - Real token_url (e.g., https://onfabric.com/oauth/token)
   - Correct OAuth scopes for MCP access

2. Register this app with OnFabric:
   - Provide redirect_uri: http://localhost:8080/callback
   - Get client_id (and client_secret if required)
   - Document required scopes

3. Test with real OAuth server:
   - Run: fabric-dashboard auth
   - Verify full flow works
   - Confirm token is valid for MCP API calls

4. Update MCPClient.call_tool() to use token in API requests:
   - Add Authorization header: Bearer {access_token}
   - Implement real MCP connection with langchain-mcp
" > docs/oauth_setup_todo.md
```

**Step 6: Commit**

```bash
git add docs/oauth_setup_todo.md
git commit -m "docs: add OAuth configuration TODO for production setup"
```

---

## Summary

**What we built:**
1. ‚úÖ OAuth configuration module
2. ‚úÖ Local redirect server for authorization callback
3. ‚úÖ OAuth flow manager with browser integration
4. ‚úÖ Token storage using .env file
5. ‚úÖ `fabric-dashboard auth` CLI command
6. ‚úÖ MCPClient integration to load and use tokens
7. ‚úÖ Complete test suite for all components
8. ‚úÖ Documentation and examples

**What's NOT implemented yet (by design):**
- ‚ùå Real MCP server connection (still stubbed)
- ‚ùå Actual API calls using the token
- ‚ùå Token refresh logic
- ‚ùå Real OnFabric OAuth endpoints (using placeholders)

**Next steps for production:**
1. Get real OAuth credentials from OnFabric
2. Update `oauth_config.py` with real URLs and client_id
3. Implement real MCP connection in `MCPClient.connect()`
4. Add Authorization header to `call_tool()` for API requests
5. Implement token refresh if OnFabric provides refresh tokens

**Testing the MVP:**
```bash
# 1. Install dependencies
uv pip install -e .

# 2. Run tests
pytest fabric_dashboard/tests/ -v

# 3. Try auth flow (will timeout without real OAuth server)
fabric-dashboard auth

# 4. Manually add test token and verify loading works
echo "ONFABRIC_ACCESS_TOKEN=test_token" >> .env
python -c "from fabric_dashboard.mcp.client import MCPClient; c = MCPClient('onfabric'); c.connect(); print('Token loaded:', c.access_token)"
```

**For junior developers:**
- Each task is independent and testable
- Follow TDD: write test ‚Üí run (fail) ‚Üí implement ‚Üí run (pass) ‚Üí commit
- Read the "Prerequisites Understanding" section if OAuth concepts are new
- Ask questions if anything is unclear!
- Don't skip the commits - they create a clear history of progress
